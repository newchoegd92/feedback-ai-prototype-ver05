# admin_app.py ‚Äî Í¥ÄÎ¶¨ÏûêÏö©(Î¶¨Î∑∞/ÏäπÏù∏/ÎÇ¥Î≥¥ÎÇ¥Í∏∞/Ï¥àÏïàÏÉùÏÑ±)
# -----------------------------------------------------------
# ‚úÖ ÌïÑÏàò Secrets (Streamlit ‚Üí Manage app ‚Üí Settings ‚Üí Secrets)
# project_id = "feedback-ai-prototype-ver05"
# location   = "us-central1"
# endpoint_name = "projects/800102005669/locations/us-central1/endpoints/6803710882468593664"
#
# raw_bucket_name = "feedback-proto-ai-raw"
# raw_prefix      = "raw_submissions"
#
# # Î≥ÑÎèÑ Î≤ÑÌÇ∑Ïù¥ ÏóÜÎã§Î©¥ rawÏôÄ ÎèôÏùºÌïòÍ≤å ÏÑ§Ï†ïÌï¥ÎèÑ Îê©ÎãàÎã§.
# cur_bucket_name = "feedback-proto-ai-raw"
# cur_prefix      = "curated"
#
# [gcp_service_account]
# ...ÏÑúÎπÑÏä§Í≥ÑÏ†ï JSON ÏõêÎ¨∏ Ï†ÑÏ≤¥...
# -----------------------------------------------------------

from __future__ import annotations

import io
import json
import uuid
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Tuple

import pandas as pd
import streamlit as st

from google.oauth2 import service_account
from google.cloud import storage
from google import genai
from google.genai import types

# -------------------- ÌéòÏù¥ÏßÄ/ÏÉÅÏàò --------------------
st.set_page_config(page_title="Í∞úÍµ¨Î¶¨ ÌïôÏäµ ÌîºÎìúÎ∞± (Admin)", page_icon="üê∏", layout="wide")

PROJECT_ID = st.secrets.get("project_id")
LOCATION   = st.secrets.get("location", "us-central1")
ENDPOINT   = (st.secrets.get("endpoint_name") or "").strip()

RAW_BUCKET = st.secrets.get("raw_bucket_name", "")
RAW_PREFIX = (st.secrets.get("raw_prefix") or "raw_submissions").strip().strip("/")

CUR_BUCKET = st.secrets.get("cur_bucket_name", RAW_BUCKET or "")
CUR_PREFIX = (st.secrets.get("cur_prefix") or "curated").strip().strip("/")

SCOPES = ["https://www.googleapis.com/auth/cloud-platform"]

# -------------------- Ïù∏Ï¶ù/ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ --------------------
try:
    credentials = service_account.Credentials.from_service_account_info(
        st.secrets["gcp_service_account"], scopes=SCOPES
    )
except Exception as e:
    st.error("SecretsÏùò [gcp_service_account] ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.\n" + repr(e))
    st.stop()

try:
    client = genai.Client(
        vertexai=True,
        project=PROJECT_ID,
        location=LOCATION,
        credentials=credentials,
    )
    storage_client = storage.Client(project=PROJECT_ID, credentials=credentials)
except Exception as e:
    st.error("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:\n" + repr(e))
    st.stop()

# -------------------- Î™®Îç∏ ÏùëÎãµ Ïú†Ìã∏ --------------------
def extract_text(resp) -> str:
    """google.genai ÏùëÎãµÏóêÏÑú ÌÖçÏä§Ìä∏Î•º ÏµúÎåÄÌïú Í∏ÅÏñ¥ Î™®ÏïÑ Î∞òÌôò"""
    if getattr(resp, "text", None):
        return (resp.text or "").strip()

    chunks: List[str] = []
    for c in getattr(resp, "candidates", []) or []:
        content = getattr(c, "content", None)
        parts = getattr(content, "parts", None) if content else None
        if parts:
            for p in parts:
                t = getattr(p, "text", None)
                if t:
                    chunks.append(t)
    return "\n".join(chunks).strip()

def is_blocked(resp) -> Tuple[bool, str]:
    """Ï∞®Îã® Ïó¨Î∂ÄÏôÄ Í∞ÑÎã® ÏÇ¨Ïú†Î•º Î∞òÌôò"""
    reasons: List[str] = []
    for c in getattr(resp, "candidates", []) or []:
        fr = getattr(c, "finish_reason", "")
        if str(fr).upper() in ("SAFETY", "BLOCKLIST"):
            reasons.append(str(fr))
        for r in getattr(c, "safety_ratings", []) or []:
            cat = getattr(r, "category", "")
            th  = getattr(r, "probability", "") or getattr(r, "threshold", "")
            if cat or th:
                reasons.append(f"{cat}:{th}")
    return (len(reasons) > 0, ", ".join(dict.fromkeys(reasons)))

def call_model(model_name: str, prompt_text: str) -> Tuple[str, Dict[str, Any]]:
    """ÏóîÎìúÌè¨Ïù∏Ìä∏ Ìò∏Ï∂ú ‚Üí (ÌÖçÏä§Ìä∏, Î©îÌÉÄ)
    1) Ïä§Ìä∏Î¶¨Î∞çÏúºÎ°ú Ïö∞ÏÑ† ÏàòÏã†Ìï¥ Ìï©ÏπòÍ∏∞
    2) Í∑∏ÎûòÎèÑ ÎπÑÎ©¥ ÎπÑ-Ïä§Ìä∏Î¶¨Î∞ç Ìïú Î≤à Îçî ÏãúÎèÑ(Î≥¥ÏàòÏö©)
    """
    cfg = types.GenerateContentConfig(
        temperature=0.7,
        max_output_tokens=1024,
        response_mime_type="text/plain",   # Î™ÖÏãúÏ†ÅÏúºÎ°ú ÌÖçÏä§Ìä∏ ÏùëÎãµ ÏöîÍµ¨
        safety_settings=[
            types.SafetySetting(category="HARM_CATEGORY_HARASSMENT",        threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_HATE_SPEECH",       threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold="OFF"),
            types.SafetySetting(category="HARM_CATEGORY_DANGEROUS_CONTENT", threshold="OFF"),
        ],
    )

    # 1) Ïä§Ìä∏Î¶¨Î∞ç Ïö∞ÏÑ†
    chunks: List[str] = []
    try:
        for chunk in client.models.generate_content_stream(
            model=model_name,
            contents=[types.Content(role="user", parts=[types.Part.from_text(text=prompt_text)])],
            config=cfg,
        ):
            if getattr(chunk, "text", None):
                chunks.append(chunk.text)
    except Exception as e:
        # Ïä§Ìä∏Î¶¨Î∞ç ÏûêÏ≤¥Í∞Ä Ïã§Ìå®ÌïòÎ©¥ ÏïÑÎûò ÎπÑ-Ïä§Ìä∏Î¶¨Î∞çÏúºÎ°ú ÎÑòÏñ¥Í∞ê
        pass

    text = "".join(chunks).strip()

    # 2) Ïä§Ìä∏Î¶¨Î∞çÏù¥ ÎπÑÏóàÏúºÎ©¥ ÎπÑ-Ïä§Ìä∏Î¶¨Î∞çÏúºÎ°ú Ìïú Î≤à Îçî
    meta = {"blocked": False, "reason": ""}
    if not text:
        resp = client.models.generate_content(
            model=model_name,
            contents=[types.Content(role="user", parts=[types.Part.from_text(text=prompt_text)])],
            config=cfg,
        )
        text = extract_text(resp)
        blocked, reason = is_blocked(resp)
        meta["blocked"], meta["reason"] = blocked, reason or ""

    return text, meta


# -------------------- GCS Ïú†Ìã∏ --------------------
def gcs_upload_bytes(bucket: str, path: str, data: bytes, content_type: str):
    b = storage_client.bucket(bucket).blob(path)
    b.cache_control = "no-cache"
    b.upload_from_file(io.BytesIO(data), size=len(data), content_type=content_type)

def upload_json(bucket: str, path: str, obj: Dict[str, Any]):
    gcs_upload_bytes(bucket, path, json.dumps(obj, ensure_ascii=False, indent=2).encode("utf-8"), "application/json")

def read_json(bucket: str, path: str) -> Dict[str, Any]:
    b = storage_client.bucket(bucket).blob(path)
    return json.loads(b.download_as_bytes())

def delete_object(bucket: str, path: str):
    storage_client.bucket(bucket).blob(path).delete()

@st.cache_data(ttl=60)
def list_keys(bucket: str, prefix: str) -> List[str]:
    """Î≤ÑÌÇ∑Ïùò prefix ÌïòÏúÑ .json ÌÇ§Î•º ÏµúÏã†ÏàúÏúºÎ°ú Î∞òÌôò (Î≤ÑÌÇ∑ ÏóÜÏñ¥ÎèÑ Ïï±Ïù¥ Ï£ΩÏßÄ ÏïäÍ≤å Î≥¥Ìò∏)"""
    if not bucket or not prefix:
        return []
    try:
        blobs = storage_client.list_blobs(bucket, prefix=f"{prefix}/")
        keys = [b.name for b in blobs if b.name.endswith(".json")]
        keys.sort(reverse=True)
        return keys
    except Exception as e:
        st.warning(f"Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§: {e}")
        return []

def key_date(key: str) -> str:
    # prefix/YYYY-MM-DD/file.json ‚Üí YYYY-MM-DD
    parts = key.split("/")
    if len(parts) >= 3:
        return parts[1]
    return ""

def filter_keys_by_date(keys: List[str], start: date, end: date) -> List[str]:
    s = start.strftime("%Y-%m-%d")
    e = end.strftime("%Y-%m-%d")
    return [k for k in keys if (d:=key_date(k)) and (s <= d <= e)]

def load_entries(bucket: str, keys: List[str]) -> List[Dict[str, Any]]:
    out = []
    for k in keys:
        try:
            d = read_json(bucket, k)
            d["_bucket"] = bucket
            d["_key"] = k
            out.append(d)
        except Exception:
            pass  # ÏùΩÍ∏∞ Ïã§Ìå® Ìï≠Î™©ÏùÄ Ïä§ÌÇµ
    return out

def curated_key_from_raw(raw_key: str) -> str:
    # raw_submissions/2025-08-26/xxxx.json ‚Üí curated/2025-08-26/xxxx.json
    parts = raw_key.split("/", 2)
    if len(parts) >= 3:
        return f"{CUR_PREFIX}/{parts[1]}/{parts[2]}"
    day = datetime.utcnow().strftime("%Y-%m-%d")
    return f"{CUR_PREFIX}/{day}/{uuid.uuid4().hex[:10]}.json"

def contains_keyword(e: Dict[str, Any], kw: str) -> bool:
    if not kw:
        return True
    kw = kw.lower()
    for field in ("prompt","ai_response","approved_response","review_notes"):
        v = (e.get(field) or "")
        if kw in v.lower():
            return True
    return False

def to_jsonl_lines(entries: List[Dict[str, Any]]) -> List[str]:
    lines = []
    for e in entries:
        prompt = (e.get("prompt") or "").strip()
        out = (e.get("approved_response") or e.get("ai_response") or "").strip()
        if not prompt or not out:
            continue
        obj = {
            "contents": [
                {"role": "user",  "parts": [{"text": prompt}]},
                {"role": "model", "parts": [{"text": out}]},
            ]
        }
        lines.append(json.dumps(obj, ensure_ascii=False))
    return lines

def to_dataframe(entries: List[Dict[str, Any]]) -> pd.DataFrame:
    cols = [
        "timestamp","prompt","ai_response","approved_response","approved_by","approved_at",
        "review_notes","used_model","source_raw_bucket","source_raw_key","_bucket","_key"
    ]
    rows = []
    for e in entries:
        rows.append({
            "timestamp": e.get("timestamp"),
            "prompt": e.get("prompt"),
            "ai_response": e.get("ai_response"),
            "approved_response": e.get("approved_response"),
            "approved_by": e.get("approved_by"),
            "approved_at": e.get("approved_at"),
            "review_notes": e.get("review_notes"),
            "used_model": e.get("used_model"),
            "source_raw_bucket": e.get("source_raw_bucket"),
            "source_raw_key": e.get("source_raw_key"),
            "_bucket": e.get("_bucket"),
            "_key": e.get("_key"),
        })
    return pd.DataFrame(rows, columns=cols)

# -------------------- ÏÇ¨Ïù¥ÎìúÎ∞î --------------------
with st.sidebar:
    st.markdown("### ÌôòÍ≤Ω Ï†ïÎ≥¥")
    st.write(f"Project: `{PROJECT_ID}`")
    st.write(f"Location: `{LOCATION}`")
    st.write(f"Endpoint:\n`{ENDPOINT or '(ÎØ∏ÏÑ§Ï†ï)'}`")
    st.write("---")
    st.write(f"raw: `gs://{RAW_BUCKET}/{RAW_PREFIX}`")
    st.write(f"curated: `gs://{CUR_BUCKET or RAW_BUCKET}/{CUR_PREFIX}`")

# -------------------- ÌÉ≠ --------------------
tab_gen, tab_review, tab_export = st.tabs(["üß™ ÏÉùÏÑ±(Ï¥àÏïà)", "üóÇÔ∏è Ï†úÏ∂ú Î¶¨Î∑∞", "üì¶ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞"])

# == ÌÉ≠ 1: ÏÉùÏÑ±(Ï¥àÏïà) ==
with tab_gen:
    st.header("üß™ ÏÉùÏÑ±(Ï¥àÏïà)")
    if not ENDPOINT:
        st.warning("SecretsÏùò endpoint_nameÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.")
    prompt = st.text_area("ÌïôÏÉùÏùò ÏÉÅÌô©ÏùÑ ÏûêÏÑ∏Ìûà ÏûÖÎ†•:", height=180, key="admin_gen_prompt")
    if st.button("AI Ï¥àÏïà ÏÉùÏÑ±", use_container_width=True):
        if not prompt.strip():
            st.warning("ÌîÑÎ°¨ÌîÑÌä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
        else:
            with st.spinner("ÏÉùÏÑ± Ï§ë..."):
                try:
                    ai_text, meta = call_model(ENDPOINT, prompt)
                    if ai_text:
                        st.session_state["admin_last_ai"] = ai_text
                        st.success("Ï¥àÏïà ÏÉùÏÑ± ÏôÑÎ£å")
                    else:
                        st.session_state["admin_last_ai"] = ""
                        msg = "Î™®Îç∏Ïù¥ Îπà ÏùëÎãµÏùÑ Î∞òÌôòÌñàÏäµÎãàÎã§."
                        if meta.get("blocked"):
                            msg += f" (ÏÇ¨Ïú†: {meta.get('reason')})"
                        st.warning(msg)
                        with st.expander("ÎîîÎ≤ÑÍ∑∏"):
                            st.json(meta)
                except Exception as e:
                    st.error("ÏÉùÏÑ± Ïã§Ìå®"); st.exception(e)

    if st.session_state.get("admin_last_ai"):
        st.subheader("ü§ñ AI Ï¥àÏïà")
        st.text_area("AI Ï¥àÏïà Ï∂úÎ†•", st.session_state["admin_last_ai"], height=280)

        st.subheader("‚úçÔ∏è ÏµúÏ¢Ö ÏäπÏù∏Î≥∏ ÏûëÏÑ± ÌõÑ Ï¶âÏãú curated Ï†ÄÏû•")
        approved = st.text_area("ÏµúÏ¢Ö ÌîºÎìúÎ∞±", value=st.session_state["admin_last_ai"], height=240)
        if st.button("‚úÖ ÏäπÏù∏ Ï†ÄÏû•(ÏÉà Ìï≠Î™©)", type="primary"):
            try:
                ts = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
                day = datetime.utcnow().strftime("%Y-%m-%d")
                out = {
                    "timestamp": ts,
                    "prompt": prompt,
                    "ai_response": st.session_state["admin_last_ai"],
                    "approved_response": approved.strip(),
                    "approved_by": "admin",
                    "approved_at": ts,
                    "used_model": ENDPOINT,
                    "review_notes": "",
                }
                fname = f"{uuid.uuid4().hex[:10]}.json"
                key = f"{CUR_PREFIX}/{day}/{fname}"
                upload_json(CUR_BUCKET or RAW_BUCKET, key, out)
                st.success(f"curated Ï†ÄÏû• ÏôÑÎ£å: gs://{CUR_BUCKET or RAW_BUCKET}/{key}")
            except Exception as e:
                st.error("Ï†ÄÏû• Ïã§Ìå®"); st.exception(e)

# == ÌÉ≠ 2: Ï†úÏ∂ú Î¶¨Î∑∞ ==
with tab_review:
    st.header("üóÇÔ∏è Ï†úÏ∂ú Î¶¨Î∑∞")
    if not RAW_BUCKET:
        st.info("raw Î≤ÑÌÇ∑Ïù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. SecretsÏóê raw_bucket_name/raw_prefixÎ•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.")
    else:
        # ---- ÌïÑÌÑ∞ UI ----
        today = date.today()
        default_start = today - timedelta(days=7)
        c1, c2, c3, c4 = st.columns([1,1,1,1])
        with c1:
            start_date = st.date_input("ÏãúÏûëÏùº", value=default_start)
        with c2:
            end_date = st.date_input("Ï¢ÖÎ£åÏùº", value=today)
        with c3:
            keyword = st.text_input("ÌÇ§ÏõåÎìú(ÌîÑÎ°¨ÌîÑÌä∏/ÏùëÎãµ/Î©îÎ™® Í≤ÄÏÉâ)", "")
        with c4:
            limit = st.number_input("ÏµúÎåÄ Î°úÎìú Ïàò", min_value=50, max_value=3000, value=600, step=50)

        # ---- ÌÇ§ Î™©Î°ù/ÌïÑÌÑ∞ ----
        all_keys = list_keys(RAW_BUCKET, RAW_PREFIX)
        cand_keys = filter_keys_by_date(all_keys, start_date, end_date)[: int(limit)]
        entries = load_entries(RAW_BUCKET, cand_keys)
        if keyword.strip():
            entries = [e for e in entries if contains_keyword(e, keyword)]
        st.caption(f"ÌïÑÌÑ∞ Í≤∞Í≥º: {len(entries)}Í±¥")

        # Î™©Î°ù ÎùºÎ≤®
        def label_of(e):
            d = e.get("timestamp") or key_date(e.get("_key",""))
            p = (e.get("prompt") or "").replace("\n"," ")
            if len(p) > 36: p = p[:36]+"‚Ä¶"
            return f"{d} | {p}"

        options = ["(ÏÑ†ÌÉù)"] + [label_of(e) for e in entries]
        sel = st.selectbox("Í≤ÄÌÜ†Ìï† Ìï≠Î™©", options, index=0, key="review_select")

        if sel != "(ÏÑ†ÌÉù)":
            idx = options.index(sel) - 1
            item = entries[idx]

            st.subheader("ÏõêÎ≥∏ Ï†úÏ∂ú")
            st.write("Ï†úÏ∂úÏãúÍ∞Å:", item.get("timestamp"))
            st.write("ÌîÑÎ°¨ÌîÑÌä∏:")
            st.code(item.get("prompt",""), language="text")
            st.write("AI Ï¥àÏïà:")
            st.text_area("ÏõêÎ≥∏ AI Ï¥àÏïà", item.get("ai_response",""), height=220)

            st.subheader("‚úçÔ∏è Í¥ÄÎ¶¨Ïûê ÏäπÏù∏Î≥∏(ÏàòÏ†ï/Î≥¥ÏôÑÌïòÏó¨ ÏûÖÎ†•)")
            approved_text = st.text_area(
                "ÏµúÏ¢Ö ÌîºÎìúÎ∞±(ÌïôÏäµÎç∞Ïù¥ÌÑ∞Î°ú Ïì∞Ïùº ÎãµÎ≥Ä)",
                value=item.get("approved_response", item.get("ai_response","")),
                height=260,
                key="approved_text_area",
            )
            cb1, cb2, cb3 = st.columns([1,1,1])
            with cb1:
                delete_after = st.checkbox("ÏäπÏù∏ ÌõÑ raw ÏÇ≠Ï†ú", value=False)
            with cb2:
                notes = st.text_input("Í¥ÄÎ¶¨Ïûê Î©îÎ™®(ÏÑ†ÌÉù)", value=item.get("review_notes",""))
            with cb3:
                save_btn = st.button("‚úÖ ÏäπÏù∏ Ï†ÄÏû•", type="primary")

            if save_btn:
                try:
                    ts = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
                    out = {
                        **item,
                        "approved_response": approved_text.strip(),
                        "approved_by": "admin",
                        "approved_at": ts,
                        "review_notes": notes,
                        "source_raw_bucket": item.get("_bucket"),
                        "source_raw_key": item.get("_key"),
                    }
                    out_key = curated_key_from_raw(item.get("_key",""))
                    upload_json(CUR_BUCKET or RAW_BUCKET, out_key, out)
                    st.success(f"curated Ï†ÄÏû• ÏôÑÎ£å ‚Üí gs://{CUR_BUCKET or RAW_BUCKET}/{out_key}")
                    if delete_after:
                        try:
                            delete_object(item.get("_bucket"), item.get("_key"))
                            st.info("ÏõêÎ≥∏(raw) ÏÇ≠Ï†ú ÏôÑÎ£å")
                        except Exception as de:
                            st.warning(f"ÏõêÎ≥∏ ÏÇ≠Ï†ú Ïã§Ìå®: {de}")
                except Exception as se:
                    st.error("ÏäπÏù∏ Ï†ÄÏû• Ïã§Ìå®"); st.exception(se)

            # Ïù¥Ï†Ñ/Îã§Ïùå
            pn1, pn2 = st.columns([1,1])
            with pn1:
                if st.button("‚óÄ Ïù¥Ï†Ñ"):
                    if idx - 1 >= 0:
                        st.session_state["review_select"] = options[idx]  # Ïù¥Ï†Ñ ÎùºÎ≤®
                        st.rerun()
            with pn2:
                if st.button("Îã§Ïùå ‚ñ∂"):
                    if idx + 1 < len(entries):
                        st.session_state["review_select"] = options[idx+2]  # Îã§Ïùå ÎùºÎ≤®
                        st.rerun()

# == ÌÉ≠ 3: Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ==
with tab_export:
    st.header("üì¶ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ (curated)")
    if not (CUR_BUCKET or RAW_BUCKET):
        st.info("curated Ï†ÄÏû•ÏÜåÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    else:
        t1, t2, t3, t4 = st.columns([1,1,1,1])
        with t1:
            start_date2 = st.date_input("ÏãúÏûëÏùº", value=date.today() - timedelta(days=30), key="exp_start")
        with t2:
            end_date2 = st.date_input("Ï¢ÖÎ£åÏùº", value=date.today(), key="exp_end")
        with t3:
            keyword2 = st.text_input("ÌÇ§ÏõåÎìú(ÌîÑÎ°¨ÌîÑÌä∏/ÏùëÎãµ/Î©îÎ™® Í≤ÄÏÉâ)", "", key="exp_kw")
        with t4:
            limit2 = st.number_input("ÏµúÎåÄ Î°úÎìú Ïàò", min_value=50, max_value=5000, value=1500, step=50, key="exp_lim")

        ckeys_all = list_keys(CUR_BUCKET or RAW_BUCKET, CUR_PREFIX)
        ckeys = filter_keys_by_date(ckeys_all, start_date2, end_date2)[: int(limit2)]
        centries = load_entries(CUR_BUCKET or RAW_BUCKET, ckeys)
        if keyword2.strip():
            centries = [e for e in centries if contains_keyword(e, keyword2)]
        st.caption(f"ÌïÑÌÑ∞ Í≤∞Í≥º: {len(centries)}Í±¥")

        if centries:
            df = to_dataframe(centries)
            st.dataframe(df.head(30), use_container_width=True)

            # CSV Îã§Ïö¥Î°úÎìú
            csv_bytes = df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")
            st.download_button(
                "‚¨áÔ∏è CSV Îã§Ïö¥Î°úÎìú", data=csv_bytes, file_name="curated_export.csv", mime="text/csv"
            )

            # JSONL Îã§Ïö¥Î°úÎìú (Vertex ÌäúÎãùÏö© Ìè¨Îß∑)
            lines = to_jsonl_lines(centries)
            jsonl_bytes = ("\n".join(lines)).encode("utf-8")
            st.download_button(
                "‚¨áÔ∏è JSONL Îã§Ïö¥Î°úÎìú (Vertex ÌäúÎãùÏö©)",
                data=jsonl_bytes,
                file_name="curated_tuning.jsonl",
                mime="application/json",
            )
        else:
            st.info("ÎÇ¥Î≥¥ÎÇº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÎÇ†Ïßú/ÌÇ§ÏõåÎìúÎ•º Ï°∞Ï†ïÌï¥ Î≥¥ÏÑ∏Ïöî.")
